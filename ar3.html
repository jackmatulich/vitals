<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AR Cube + Ultrasound Probe with Full Rotation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/build/ar-threex.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    .control-panel {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: sans-serif;
      padding: 10px;
      z-index: 10;
    }
    .slider-group {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    .slider-group label {
      width: 80px;
    }
    .slider-group input {
      flex: 1;
    }
    .value-display {
      width: 50px;
      text-align: right;
      margin-left: 10px;
    }
  </style>
</head>
<body>

<div class="control-panel">
  <div class="slider-group"><label>Pos X</label><input type="range" id="posX" min="-1" max="1" step="0.01" value="0.2"><div class="value-display" id="valPosX">0.2</div></div>
  <div class="slider-group"><label>Pos Y</label><input type="range" id="posY" min="-1" max="1" step="0.01" value="0"><div class="value-display" id="valPosY">0</div></div>
  <div class="slider-group"><label>Pos Z</label><input type="range" id="posZ" min="-1" max="1" step="0.01" value="0"><div class="value-display" id="valPosZ">0</div></div>
  <div class="slider-group"><label>Rot X</label><input type="range" id="rotX" min="0" max="360" step="1" value="90"><div class="value-display" id="valRotX">90</div></div>
  <div class="slider-group"><label>Rot Y</label><input type="range" id="rotY" min="0" max="360" step="1" value="180"><div class="value-display" id="valRotY">180</div></div>
  <div class="slider-group"><label>Rot Z</label><input type="range" id="rotZ" min="0" max="360" step="1" value="0"><div class="value-display" id="valRotZ">0</div></div>
  <div class="slider-group"><label>Scale</label><input type="range" id="scale" min="0.01" max="1" step="0.01" value="0.4"><div class="value-display" id="valScale">0.4</div></div>
</div>

<script>
  let scene, camera, renderer;
  let arSource, arContext;
  const patternArray = ["letterA", "letterB", "letterC", "letterD", "letterF", "kanji"];
  const rotationArray = [
    new THREE.Vector3(-Math.PI/2,0,0), new THREE.Vector3(0,-Math.PI/2,Math.PI/2), new THREE.Vector3(Math.PI/2,0,Math.PI),
    new THREE.Vector3(-Math.PI/2,Math.PI/2,0), new THREE.Vector3(Math.PI,0,0), new THREE.Vector3(0,0,0)
  ];
  const markerRootArray = [], markerGroupArray = [];
  let sceneGroup, probeModel;

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.Camera();
    scene.add(camera);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = 'absolute';
    document.body.appendChild(renderer.domElement);

    arSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
    arSource.init(() => onResize());
    window.addEventListener('resize', () => onResize());

    arContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: 'https://raw.githack.com/AR-js-org/AR.js/master/three.js/data/camera_para.dat',
      detectionMode: 'mono'
    });
    arContext.init(() => {
      camera.projectionMatrix.copy(arContext.getProjectionMatrix());
    });

    for (let i = 0; i < 6; i++) {
      const root = new THREE.Group();
      markerRootArray.push(root);
      scene.add(root);
      new THREEx.ArMarkerControls(arContext, root, {
        type: 'pattern',
        patternUrl: `https://stemkoski.github.io/AR-Examples/data/${patternArray[i]}.patt`
      });

      const faceGroup = new THREE.Group();
      faceGroup.position.y = -1.25 / 2;
      faceGroup.rotation.setFromVector3(rotationArray[i]);
      root.add(faceGroup);
      markerGroupArray.push(faceGroup);
    }

    sceneGroup = new THREE.Group();
    sceneGroup.scale.set(0.5, 0.5, 0.5);

    const light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(2, 4, 4);
    scene.add(light);

    const loader = new THREE.GLTFLoader();
    loader.load('https://cdn.tinyglb.com/models/2ff293225d4a4ef3878d6a631fce6dbc.glb', (gltf) => {
      probeModel = gltf.scene;
      probeModel.scale.setScalar(parseFloat(document.getElementById('scale').value));
      sceneGroup.add(probeModel);
      updateTransform(); // Initial sync
    });

    setupSliders();
  }

  function onResize() {
    arSource.onResize();
    arSource.copySizeTo(renderer.domElement);
    if (arContext.arController) {
      arSource.copySizeTo(arContext.arController.canvas);
    }
  }

  function setupSliders() {
    const ids = ["posX", "posY", "posZ", "rotX", "rotY", "rotZ", "scale"];
    ids.forEach(id => {
      const input = document.getElementById(id);
      const display = document.getElementById("val" + id.charAt(0).toUpperCase() + id.slice(1));
      input.addEventListener('input', () => {
        if (!probeModel) return;
        updateTransform();
        display.textContent = input.value;
      });
    });
  }

  function updateTransform() {
    if (!probeModel) return;
    const x = parseFloat(document.getElementById('posX').value);
    const y = parseFloat(document.getElementById('posY').value);
    const z = parseFloat(document.getElementById('posZ').value);
    const rx = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value));
    const ry = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value));
    const rz = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value));
    const s = parseFloat(document.getElementById('scale').value);

    probeModel.position.set(x, y, z);
    probeModel.rotation.set(rx, ry, rz);
    probeModel.scale.set(s, s, s);
  }

  function animate() {
    requestAnimationFrame(animate);
    if (arSource.ready) arContext.update(arSource.domElement);

    for (let i = 0; i < markerRootArray.length; i++) {
      if (markerRootArray[i].visible) {
        markerGroupArray[i].add(sceneGroup);
        break;
      }
    }

    renderer.render(scene, camera);
  }
</script>

</body>
</html>